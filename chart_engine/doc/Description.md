# Chart 引擎实现报告

## 一、谱面校验模块 (check.py)

### 功能概述

谱面校验模块是 Chart 引擎的基础组件，负责对谱面文件进行全面的格式检查和逻辑验证，确保谱面文件符合游戏引擎的要求。该模块在谱面生成、ROM 编译等关键流程中起到质量保障作用，能够有效防止因格式错误导致的系统异常。模块采用早期失败策略，一旦发现错误立即返回并输出详细的错误信息，包括错误类型、出错行号和具体错误值，这大大提高了问题定位的效率。

### 实现思路

谱面文件采用简洁的文本格式，第一行为 BPM 值声明，格式为 `bpm=<整数>`，后续行为事件行，格式为 `(time,type,trace)`，其中 time 表示事件发生的时间点（非负整数），type 表示事件类型（tap、hold_start、hold_mid），trace 表示轨道编号（0 或 1）。校验过程分为四个主要阶段：文件读取与基础检查、BPM 格式校验、事件行逐行校验和长条闭合检查。

在文件读取阶段，模块首先验证文件存在性和非空性。随后检查第一行的 BPM 格式，确保以 `bpm=` 开头且值为正整数。对于事件行的校验，模块维护两个关键状态：全局上一个事件的时间值 `last_time` 和每个轨道上一个事件的信息 `last_by_trace`。对每个事件行，模块首先使用正则表达式进行格式匹配，然后依次验证事件类型有效性、轨道编号有效性、时间值非负性、全局时间单调性（允许不同轨道在同一时间点有事件，但整体时间必须单调不减）、同轨时间严格递增（同一轨道上的事件时间必须严格递增，不允许相等）。

长条事件的校验是模块的核心难点。模块要求 `hold_mid` 必须紧接在 `hold_start` 或 `hold_mid` 之后，且时间差必须为 1，这意味着长条事件必须是连续的时间序列。同时，`hold_start` 后必须跟随连续的 `hold_mid`，直到长条结束，不能出现 `hold_start` 后直接跟其他类型事件的情况。在遍历结束后，模块还会检查所有轨道是否有未闭合的 `hold_start`，确保每个长条事件都被正确闭合。

### 代码结构说明

模块的核心函数是 `chart_check(chart_name, chart_path=None)`，该函数接受曲目名称和可选的谱面文件路径作为参数，返回布尔值表示校验是否通过。函数内部首先调用辅助函数 `_resolve_chart_path` 解析谱面文件路径，如果未提供路径则使用默认路径 `charts/<chart_name>/<chart_name>.txt`。模块定义了三个关键常量：`_EVENT_PATTERN` 是用于匹配事件行格式的正则表达式，`_ALLOWED_TYPES` 定义了允许的事件类型集合，`_ALLOWED_TRACES` 定义了允许的轨道编号集合。

校验过程采用单次遍历的方式，时间复杂度为 O(n)，其中 n 为事件行数。模块使用正则表达式进行格式匹配，效率较高，内存占用小，仅维护必要的状态信息。这种设计使得模块具有良好的性能表现，即使对于包含大量事件的谱面文件也能快速完成校验。

### 简单示例

一个有效的谱面示例如下所示。该谱面包含 BPM 声明、单点事件和长条事件，所有事件都符合格式要求和逻辑约束。单点事件 `(0,tap,0)` 和 `(5,tap,1)` 分别位于不同轨道，时间单调递增。长条事件从时间 10 开始，包含 `hold_start` 和三个连续的 `hold_mid`，时间差均为 1，符合长条事件的连续性要求。

```
bpm=120
(0,tap,0)
(5,tap,1)
(10,hold_start,0)
(11,hold_mid,0)
(12,hold_mid,0)
(13,hold_mid,0)
(15,tap,1)
```

常见的错误情况包括时间不单调（如第二行时间值小于第一行）、同轨时间不严格递增（如同一轨道上出现相同时间的事件）、`hold_mid` 前没有 `hold_start`（长条事件必须以 `hold_start` 开始）以及 `hold_start` 未闭合（长条事件必须以 `hold_mid` 结尾）。模块能够准确识别这些错误并输出相应的错误信息。

### 简要流程

校验流程从解析文件路径开始，首先检查文件是否存在，如果不存在则返回错误。文件存在后读取文件内容，检查文件是否为空，如果为空则返回错误。随后检查第一行的 BPM 格式，如果格式不正确则返回错误。BPM 格式正确后，初始化校验状态，包括全局时间记录和每个轨道的事件记录。接下来进入事件行遍历循环，对每个事件行首先进行格式匹配，如果格式不正确则返回错误。格式正确后提取时间、类型和轨道信息，依次校验事件类型有效性、轨道编号有效性、时间值非负性、全局时间单调性和同轨时间严格递增。对于 `hold_mid` 事件，需要额外检查是否紧接在前一个同轨的 `hold_start` 或 `hold_mid` 之后且时间差为 1。对于非 `hold_mid` 事件，如果前一个同轨事件是 `hold_start`，则必须当前事件是 `hold_mid`，否则返回错误。每个事件校验通过后更新状态记录，继续处理下一个事件。所有事件处理完成后，检查是否有未闭合的 `hold_start`，如果有则返回错误，否则返回校验通过。

---

## 二、随机谱面生成模块 (random_gen.py)

### 功能概述

随机谱面生成模块实现了基于概率的随机谱面生成功能，能够根据指定的 BPM、时长、随机种子等参数自动生成符合格式要求的谱面文件。该模块采用基于节拍的循环生成策略，通过概率控制事件类型分布，生成包含单点事件和长条事件的随机谱面。模块支持随机种子功能，确保相同种子能够生成完全相同的谱面，这对于测试和调试具有重要意义。生成的谱面文件可以直接用于后续的校验和 ROM 编译流程。

### 实现思路

模块的核心思想是在节拍序列上随机生成事件，使用概率控制事件类型的分布。首先根据 BPM 和时长计算总节拍数，公式为 `maxlength = bpm * length_seconds / 60`。然后从节拍位置 0 开始，循环生成事件直到达到总节拍数。每次循环中，模块首先生成一个 2 到 6 之间的随机整数作为事件间隔，然后生成一个 1 到 100 之间的随机数用于决定事件类型，最后生成一个 1 到 3 之间的随机数用于决定轨道选择。

事件类型的选择基于概率分布：当随机数小于等于 85 时生成单点事件（tap），概率为 85%；当随机数大于 85 时生成长条事件（hold），概率为 15%。这种分布设计使得生成的谱面以单点事件为主，长条事件作为点缀，符合大多数音乐游戏的谱面特征。轨道选择有三种情况：trace 为 1 时仅在轨道 0 生成事件，trace 为 2 时仅在轨道 1 生成事件，trace 为 3 时在双轨道同时生成事件，这增加了谱面的多样性和挑战性。

对于单点事件，模块根据轨道选择在相应位置生成 `tap` 事件，然后更新节拍位置为当前位置加上事件间隔。对于长条事件，模块首先生成一个 3 到 8 之间的随机数作为长条长度，然后生成两个额外的随机数用于决定是否在长条首尾添加额外的单点事件（这种设计增加了谱面的复杂度）。长条事件的生成采用循环方式，在循环的开始位置生成 `hold_start`，在中间位置生成 `hold_mid`，在结束位置生成最后一个 `hold_mid`。长条生成完成后，更新节拍位置为当前位置加上事件间隔再加上长条长度减一。

### 代码结构说明

模块的主函数是 `generate_random_chart(output_dir, name="Random", bpm=120, length_seconds=60, seed=None)`，该函数接受输出目录、文件名、BPM、时长和随机种子作为参数，返回生成的文件路径或 None（表示失败）。函数首先设置随机种子（如果提供），这确保了相同种子能够生成相同的谱面。然后创建输出文件，如果目录不存在则自动创建。接下来计算总节拍数并初始化事件列表，列表的第一项为 BPM 声明行。

生成过程采用 while 循环，循环条件为当前节拍位置小于总节拍数。在循环内部，根据随机数决定生成单点事件还是长条事件，然后根据轨道选择生成相应的事件行并添加到事件列表中。所有事件生成完成后，将事件列表写入文件。模块还包含一个测试函数 `test_generate_random_chart()`，该函数包含多个测试用例，包括基本功能测试、固定种子可重复性测试、文件格式验证、事件格式验证和错误处理测试。

模块的错误处理机制完善，对于文件创建失败和文件写入失败都进行了异常捕获，并输出详细的错误信息。模块的时间复杂度为 O(n)，其中 n 为总节拍数，空间复杂度也为 O(n)，需要存储所有事件行。由于使用 Python 标准库的 random 模块，随机数生成性能良好，整体性能表现优秀。

### 简单示例

假设使用参数 `bpm=120`、`length_seconds=60`、`seed=42` 生成谱面，可能得到如下输出。该谱面展示了单点事件和长条事件的混合分布，单点事件占主导地位，长条事件作为点缀。可以看到，单点事件的时间间隔在 2 到 6 个节拍之间随机变化，长条事件从时间 18 开始，包含 `hold_start` 和三个连续的 `hold_mid`，符合长条事件的连续性要求。双轨道同时触发的情况（如时间 12 处）增加了谱面的挑战性。

```
bpm=120
(3,tap,0)
(8,tap,1)
(12,tap,0)
(12,tap,1)
(18,hold_start,0)
(19,hold_mid,0)
(20,hold_mid,0)
(21,hold_mid,0)
(25,tap,1)
(30,tap,0)
```

### 简要流程

生成流程从设置随机种子开始（如果提供），然后创建输出文件，如果文件创建失败则返回错误。文件创建成功后，计算总节拍数并初始化事件列表和节拍位置。接下来进入主循环，循环条件为当前节拍位置小于总节拍数。在循环内部，首先生成事件间隔、事件类型随机数和轨道选择随机数。根据事件类型随机数判断生成单点事件还是长条事件。如果是单点事件，根据轨道选择生成相应的 `tap` 事件并添加到事件列表，然后更新节拍位置。如果是长条事件，首先生成长条长度和首尾额外事件标志，然后进入长条生成循环。在长条生成循环中，根据当前位置生成 `hold_start`（开始位置）、`hold_mid`（中间位置）或最后一个 `hold_mid`（结束位置），并根据首尾标志决定是否添加额外的 `tap` 事件。长条生成完成后，更新节拍位置并返回主循环。主循环结束后，将所有事件写入文件，如果写入失败则返回错误，否则返回生成的文件路径。

---

## 三、ROM 生成模块 (rom_gen.py)

### 功能概述

ROM 生成模块实现了从谱面文件到 Verilog ROM 模块的完整转换功能，是连接软件谱面设计和硬件实现的关键桥梁。该模块读取经过校验的谱面文件，解析其中的事件信息，将其转换为 FPGA 可用的 ROM 数据格式，并自动生成标准的 Verilog ROM 模块代码。同时，模块还会提取谱面文件中的 BPM 值，计算相应的时钟分频系数，并自动更新顶层 Verilog 模块的 BPM 参数，确保硬件时钟与谱面节拍同步。生成的 ROM 模块可以直接用于 FPGA 综合和实现，大大简化了从谱面设计到硬件部署的流程。

### 实现思路

模块的核心任务是将文本格式的谱面文件转换为硬件可用的 ROM 数据。谱面文件中的每个事件包含时间、类型和轨道三个信息，需要将这些信息编码为 4 位的 ROM 数据。编码规则如下：每个时间点的 ROM 数据为 4 位，低 2 位表示轨道 0（notedown）的事件类型，高 2 位表示轨道 1（noteup）的事件类型。事件类型的编码映射为：无事件编码为 00，tap 编码为 01，hold_start 编码为 10，hold_mid 编码为 11。这种编码方式使得同一时间点可以同时存在不同轨道的事件，通过位掩码操作可以独立更新每个轨道的数据。

BPM 到时钟分频的转换是模块的另一个重要功能。FPGA 使用时钟分频来匹配 BPM，计算公式为 `div_cnt = 375000000 / bpm`，其中 375000000 是系统时钟频率（假设为 375 MHz）。模块会提取谱面文件第一行的 BPM 值，计算相应的分频系数，然后使用正则表达式在顶层 Verilog 模块中查找并替换 `div_cnt` 参数的值，实现 BPM 的自动同步。

ROM 长度的计算需要考虑硬件实现的约束。ROM 长度必须是 2 的幂次，以便于地址解码，同时要能覆盖谱面中的最大时间值。模块首先遍历所有事件找出最大时间值，然后计算大于等于该值的最小 2 的幂次作为 ROM 长度。由于硬件地址位宽限制为 12 位，ROM 长度最大为 4096，如果计算出的长度超过此限制，模块会返回错误。

### 代码结构说明

模块的主函数是 `process_chart(chart_name)`，该函数接受曲目名称作为参数，返回布尔值表示处理是否成功。函数首先解析谱面文件路径，检查文件是否存在，如果不存在则返回错误。然后调用 `chart_check` 函数进行谱面校验，如果校验失败则直接返回。校验通过后，读取谱面文件内容，解析第一行获取 BPM 值，计算时钟分频系数，并使用正则表达式更新顶层 Verilog 模块的 `div_cnt` 参数。

接下来，模块使用正则表达式解析所有事件行，提取时间、类型和轨道信息，同时记录最大时间值。根据最大时间值计算 ROM 长度，检查是否超过限制。然后初始化 ROM 数组，数组长度为计算出的 ROM 长度，所有元素初始化为 0。遍历所有事件，根据事件类型获取编码值，根据轨道选择更新 ROM 数组的相应位置。对于轨道 1 的事件，使用位掩码操作更新高 2 位，保留低 2 位；对于轨道 0 的事件，更新低 2 位，保留高 2 位。这种设计确保了不同轨道的事件可以共存于同一时间点。

ROM 数据填充完成后，模块生成 Verilog 代码。代码包括模块声明、ROM 数组声明、初始化块和组合逻辑块。初始化块中包含所有 ROM 位置的初始化语句，使用二进制格式表示。组合逻辑块中将 ROM 数据按位域分解为 `noteup` 和 `notedown` 两个输出。生成的代码写入 `verilog/ROM.v` 文件，如果写入失败则返回错误。

### 简单示例

输入谱面文件包含 BPM 声明和多个事件，每个事件包含时间、类型和轨道信息。模块首先提取 BPM 值 120，计算分频系数为 3125000，并更新顶层模块的 `div_cnt` 参数。然后解析事件，找出最大时间值为 15，计算 ROM 长度为 16（2 的 4 次方）。ROM 数据填充过程如下：时间 0 的轨道 0 事件 `tap` 编码为 01，写入 ROM[0] 的低 2 位；时间 5 的轨道 1 事件 `tap` 编码为 01，写入 ROM[5] 的高 2 位；时间 10 的轨道 0 事件 `hold_start` 编码为 10，写入 ROM[10] 的低 2 位；后续的 `hold_mid` 事件编码为 11，写入相应位置的低 2 位。

```
bpm=120
(0,tap,0)
(5,tap,1)
(10,hold_start,0)
(11,hold_mid,0)
(12,hold_mid,0)
(15,tap,1)
```

生成的 Verilog ROM 模块包含模块声明、ROM 数组声明和初始化数据。ROM 数组大小为 16，每个位置存储 4 位数据。初始化块中为每个 ROM 位置赋值，使用 4 位二进制格式。组合逻辑块中将 ROM 数据按位域分解，低 2 位输出为 `notedown`，高 2 位输出为 `noteup`。硬件可以通过地址输入访问 ROM，获取对应时间点的事件信息。

```verilog
module ROM (
    input [11:0] addr,
    output reg [1:0] noteup,
    output reg [1:0] notedown
);
reg [3:0] ROM [0:15];
initial begin
    ROM[0] = 4'b0001;
    ROM[5] = 4'b0100;
    ROM[10] = 4'b0010;
    ROM[11] = 4'b0011;
    ROM[12] = 4'b0011;
    ROM[15] = 4'b0100;
end
always @(*) begin
    {noteup, notedown} = ROM[addr];
end
endmodule
```

### 简要流程

处理流程从解析谱面文件路径开始，检查文件是否存在，如果不存在则返回错误。文件存在后调用 `chart_check` 函数进行校验，如果校验失败则返回错误。校验通过后读取谱面文件内容，解析第一行获取 BPM 值，如果 BPM 格式不正确则返回错误。BPM 格式正确后，计算时钟分频系数，使用正则表达式更新顶层 Verilog 模块的 `div_cnt` 参数，如果更新失败则返回错误。

接下来解析所有事件行，提取时间、类型和轨道信息，同时记录最大时间值。根据最大时间值计算 ROM 长度，如果超过 4096 的限制则返回错误。ROM 长度确定后，初始化 ROM 数组，所有元素设为 0。然后遍历所有事件，根据事件类型获取编码值，根据轨道选择使用位掩码操作更新 ROM 数组的相应位置。对于轨道 1 的事件，更新高 2 位；对于轨道 0 的事件，更新低 2 位。

所有事件处理完成后，生成 Verilog 代码。代码生成过程包括：添加模块声明和接口定义，添加 ROM 数组声明，添加初始化块并为每个 ROM 位置生成初始化语句，添加组合逻辑块实现数据输出。生成的代码写入 `verilog/ROM.v` 文件，如果写入失败则返回错误，否则返回处理成功。整个流程确保了从谱面文件到硬件 ROM 模块的完整转换，同时实现了 BPM 参数的自动同步。

